# Copyright (c) 2023 Yuki Kimoto
# MIT License

class File::Find {
  version "0.027";
  
  use File::Find::Info;
  use File::Find::Callback;
  
  use StringList;
  use Sys;
  use Regex;
  use Re;
  use File::Basename;
  use Fn;
  use File::Find::Callback;
  use Sys::OS;
  use Re;
  use Hash;
  use File::Spec;
  use Cwd;
  use IO::Dir;
  
  # Fields
  has follow : ro byte;
  
  has follow_skip : ro byte;
  
  has warn : ro byte;
  
  # Undocumented Fields
  has SLnkSeen : Hash of Int;
  
  has current_dir : string;
  
  has skip_pattern : string;
  
  # Class Methods
  static method new : File::Find ($options : object[] = undef) {
    
    my $self = new File::Find;
    
    my $option_names = [
      "follow",
      "follow_skip",
      "warn",
    ];
    
    Fn->check_option_names($options, $option_names);
    
    my $options_h = Hash->new($options);
    
    $self->{follow} = (byte)$options_h->get_or_default_int("follow", 0);
    
    if ($options_h->exists("follow_skip")) {
      $self->{follow_skip} = (byte)$options_h->get_int("follow_skip");
    }
    else {
      if ($self->{follow}) {
        $self->{follow_skip} = 1;
      }
    }
    
    $self->{SLnkSeen} = Hash->new;
    
    $self->{current_dir} = File::Spec->curdir // ".";
    
    $self->{skip_pattern} = "^\.{1,2}\z";
    
    $self->{warn} = (byte)$options_h->get_or_default_int("warn", 0);
    
    return $self;
  }
  
  # Instance Methods
  method find : void ($cb : File::Find::Callback, $top_dir : string) {
    
    unless ($top_dir) {
      die "The top directory \$top_dir must be defined." ;
    }
    
    my $top_dir_is_dir = 0;
    unless (Sys->d($top_dir)) {
      die "The top directory \$top_dir must be an accessible directory." ;
    }
    
    # canonicalize directory separators
    if (Sys::OS->is_windows) {
      Re->s(my $_ = [$top_dir], ["[/\\\\]", "g"], "/");
      $top_dir = $_->[0];
    }
    
    # no trailing / unless path is root
    unless (&_is_root($top_dir)) {
      Re->s(my $_ = [$top_dir], "/\z", "");
      $top_dir = $_->[0];
    }
    
    my $warn = $self->{warn};
    my $follow = $self->{follow};
    
    my $tree_queue = StringList->new;
    
    my $base_name = (string)undef;
    
    my $is_top_dir = 1;
    
    my $name = $top_dir;
    
    $tree_queue->push($name);
    
    while (1) {
      
      unless ($tree_queue->length > 0) {
        last;
      }
      
      my $name = $tree_queue->shift;
      
      my $info = File::Find::Info->new;
      $info->{name} = $name;
      
      $cb->($info);
      
      my $dir = $name;
      
      my $open_dir = 0;
      
      my $lstat = (Sys::IO::Stat)undef;
      
      eval { $lstat = Sys->lstat($dir); }
      
      if ($@) {
        if ($warn) {
          warn "Sys#lstat method failed. File:$dir, Error:$@";
        }
        next;
      }
      
      if ($lstat->l) {
        if ($follow) {
          my $stat = (Sys::IO::Stat)undef;
          
          eval { $stat = Sys->stat($dir); }
          
          if ($@) {
            if ($warn) {
              warn "Sys#stat method failed. File:$dir, Error:$@";
            }
            next;
          }
          
          if ($stat->d) {
            $open_dir = 1;
          }
        }
      }
      else {
        if ($lstat->d) {
          $open_dir = 1;
        }
      }
      
      unless ($open_dir) {
        next;
      }
      
      # Get the list of files in the current directory.
      my $dh = (IO::Dir)undef;
      eval { $dh = IO::Dir->new($dir); }
      if ($@) {
        if ($warn) {
          warn "IO::Dir#new method failed. Directory:$dir, Error:$@";
        }
        next;
      }
      
      while (my $dirent = $dh->read) {
        my $base_name = $dirent->d_name;
        
        if (Re->m($base_name, $self->{skip_pattern})) {
          next;
        }
        
        my $name = &_is_root($dir) ? "$dir$base_name" : "$dir/$base_name";
        
        $tree_queue->push($name);
      }
    }
  }
  
  private method _contract_name : string ($cdir : string, $fn : string) {
    
    if ($fn eq $self->{current_dir}) {
      return Fn->substr($cdir, 0, Fn->rindex($cdir, "/"));
    }
    
    $cdir = Fn->substr($cdir, 0, Fn->rindex($cdir, "/") + 1);
    
    Re->s(my $_ = [$fn], "^\./", "");
    $fn = $_->[0];
    
    my $abs_name = $cdir . $fn;
    
    if (Fn->substr($fn, 0, 3) eq "../") {
      while (1) {
        my $rep = Re->s(my $_ = [$abs_name], "/[^/]*/\.\./+", "/");
        $abs_name = $_->[0];
        unless ($rep) {
          last;
        }
      }
    }
    
    return $abs_name;
  }

  private static method _is_absolute : int ($path : string) {
    if (Sys::OS->is_windows) {
      return !!Re->m($path, "^(?:[A-Za-z]:)?/");
    }
    return length $path && $path->[0] == '/';
  }
  
  private static method _is_root : int ($path : string) {
    if (Sys::OS->is_windows) {
      return !!Re->m($path, "^(?:[A-Za-z]:)?/\z");
    }
    return $path eq "/";
  }
  
  private method PathCombine : string ($Base : string, $Name : string) {
    my $AbsName : string;
    
    if (&_is_absolute($Name)) {
      $AbsName= $Name;
    }
    else {
      $AbsName= $self->_contract_name($Base, $Name);
    }
    
    # (simple) check for recursion
    my $newlen= length($AbsName);
    if ($newlen <= length($Base)) {
      if (($newlen == length($Base) || Fn->substr($Base, $newlen, 1) eq "/")
          && $AbsName eq Fn->substr($Base, 0, $newlen))
      {
        return undef;
      }
    }
    return $AbsName;
  }
  
  private method _Follow_SymLink : string ($AbsName : string) {
    
    my $NewName = (string)undef;
    
    my $lstat = Sys->lstat($AbsName);
    my $DEV = $lstat->st_dev;
    my $INO = $lstat->st_ino;
    
    my $SLnkSeen = $self->{SLnkSeen};
    
    my $follow_skip = $self->{follow_skip};
    
    my $dangling_symbolic_link = 0;
    while ($lstat->l) {
      
      my $dev_ino_count = $SLnkSeen->get_int("$DEV\034$INO");
      
      if ($dev_ino_count) {
        if ($follow_skip < 2) {
          die "$AbsName is encountered a second time";
        }
        else {
          return undef;
        }
      }
      $dev_ino_count++;
      $SLnkSeen->set("$DEV\034$INO", $dev_ino_count);
      
      my $Link = Sys->readlink($AbsName);
      # canonicalize directory separators
      if (Sys::OS->is_windows) {
        Re->s(my $_ = [$Link], ["\\", "g"], "/");
        $Link = $_->[0];
      }
      $NewName= $self->PathCombine($AbsName, $Link);
      unless ($NewName) {
        if ($follow_skip < 2) {
          die "$AbsName is a recursive symbolic link";
        }
        else {
          return undef;
        }
      }
      else {
        $AbsName= $NewName;
      }
      
      $lstat = Sys->lstat($AbsName);
      $DEV = $lstat->st_dev;
      $INO = $lstat->st_ino;
      
      #  dangling symbolic link
      eval { Sys->stat($AbsName); }
      if ($@) {
        $dangling_symbolic_link = 1;
        return undef;
      }
    }
    
    my $follow = $self->{follow};
    if ($follow && !$dangling_symbolic_link && (my $_ = $SLnkSeen->get_int("$DEV\034$INO"), $SLnkSeen->set("$DEV\034$INO", $_ + 1), $_)) {
      if ( ($follow_skip < 1) || (($lstat->d) && ($follow_skip < 2)) ) {
        die "$AbsName encountered a second time";
      }
      else {
        return undef;
      }
    }
    
    return $AbsName;
  }
  
}
