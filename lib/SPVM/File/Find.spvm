# Copyright (c) 2023 Yuki Kimoto
# MIT License

class File::Find {
  version "0.027";
  
  use File::Find::Info;
  use File::Find::Callback;
  
  use StringList;
  use Sys;
  use Regex;
  use Re;
  use File::Basename;
  use Fn;
  use File::Find::Callback;
  use Sys::OS;
  use Re;
  use Hash;
  use File::Spec;
  use Cwd;
  use IO::Dir;
  
  # Fields
  has follow : ro byte;
  
  has follow_fast : ro byte;
  
  has follow_skip : ro byte;
  
  has warn : ro byte;
  
  # Undocumented Fields
  has SLnkSeen : Hash of Int;
  
  has current_dir : string;
  
  has skip_pattern : string;
  
  # Class Methods
  static method new : File::Find ($options : object[] = undef) {
    
    my $self = new File::Find;
    
    my $option_names = [
      "follow",
      "follow_fast",
      "follow_skip",
      "warn",
    ];
    
    Fn->check_option_names($options, $option_names);
    
    my $options_h = Hash->new($options);
    
    $self->{follow} = (byte)$options_h->get_or_default_int("follow", 0);
    
    $self->{follow_fast} = (byte)$options_h->get_or_default_int("follow_fast", 0);
    
    if ($options_h->exists("follow_skip")) {
      $self->{follow_skip} = (byte)$options_h->get_int("follow_skip");
    }
    else {
      if ($self->{follow} || $self->{follow_fast}) {
        $self->{follow_skip} = 1;
      }
    }
    
    $self->{SLnkSeen} = Hash->new;
    
    $self->{current_dir} = File::Spec->curdir // ".";
    
    $self->{skip_pattern} = "^\.{1,2}\z";
    
    $self->{warn} = (byte)$options_h->get_or_default_int("warn", 0);
    
    return $self;
  }
  
  # Instance Methods
  method find : void ($cb : File::Find::Callback, $top_dir : string) {
    
    my $follow_or_follow_fast = $self->follow_or_follow_fast;
    if ($follow_or_follow_fast) {
      $self->_find_dir_symlnk($cb, $top_dir);
    }
    else {
      $self->_find_dir($cb, $top_dir);
    }
  }
  
  method _find_dir : void ($cb : File::Find::Callback, $top_dir : string) {
    
    my $follow_or_follow_fast = $self->follow_or_follow_fast;
    my $follow = $self->{follow};
    
    unless ($top_dir) {
      die "invalid top directory" ;
    }
    
    # canonicalize directory separators
    if (Sys::OS->is_windows) {
      Re->s(my $_ = [$top_dir], ["[/\\\\]", "g"], "/");
      $top_dir = $_->[0];
    }
    
    # no trailing / unless path is root
    unless (&_is_root($top_dir)) {
      Re->s(my $_ = [$top_dir], "/\z", "");
      $top_dir = $_->[0];
    }
    
    my $warn = $self->{warn};
    
    my $topstat = (Sys::IO::Stat)undef;
    if ($follow_or_follow_fast) {
      eval { $topstat = Sys->stat($top_dir); }
      if ($@) {
        if ($warn) {
          warn "Can't stat $top_dir: $@";
        }
        return;
      }
    }
    else {
      eval { $topstat = Sys->lstat($top_dir); }
      if ($@) {
        if ($warn) {
          warn "Can't lstat $top_dir: $@";
        }
        return;
      }
    }
    
    my $is_dir = 0;
    my $abs_dir = (string)undef;
    if ($follow_or_follow_fast) {
      if ($topstat->d) {
        $is_dir= 1;
      }
    }
    else { # no follow
      if ($topstat->d) {
        $is_dir = 1;
      }
    }
    
    unless ($is_dir) {
      die "The top directory \$top_dir must be a directory.";
    }
    
    my $parent_dir = $top_dir;
    
    my $dir = $parent_dir;
    my $dir_with_slash = &_is_root($parent_dir) ? $parent_dir : "$parent_dir/";
    
    my $cwd = Cwd->getcwd();
    my $fullname = (string)undef;
    if ($follow_or_follow_fast) {
      if (&_is_absolute($top_dir)) {
        $fullname = $top_dir;
      }
      elsif ($top_dir eq $self->{current_dir}) {
        $fullname = $cwd;
      }
      else {  # care about any  ../
        $fullname = $self->_contract_name("$cwd/", $top_dir);
      }
      $fullname = $self->Follow_SymLink($fullname);
    }
    
    my $dirs_stack = List->new;
    my $loop_started = 0;
    while (1) {
      my $info = File::Find::Info->new;
      
      if ($loop_started) {
        my $SE = (object[])undef;
        if ($dirs_stack->length > 0) {
          
          $SE = (object[])$dirs_stack->pop;
          
          $parent_dir = $SE->[0]->(string);
          my $base_name = $SE->[1]->(string);
          
          $dir = &_is_root($parent_dir) ? "$parent_dir$base_name" : "$parent_dir/$base_name";
          $dir_with_slash = "$dir/";
        }
        else {
          last;
        }
      }
      else {
        $loop_started++;
      }
      
      $info->{dir} = $parent_dir;
      $info->{name} = $dir;
      $cb->($info);
      if ($info->{prune}) {
        next;
      }
      
      $info->{dir} = $dir;
      
      # Get the list of files in the current directory.
      my $dh = (IO::Dir)undef;
      eval { $dh = IO::Dir->new($dir); }
      if ($@) {
        if ($warn) {
          warn "Can't opendir($dir): $@";
        }
        next;
      }
      my $base_names_list = StringList->new;
      while (my $dirent = $dh->read) {
        $base_names_list->push($dirent->d_name);
      }
      $dh->close;
      
      my $base_names = $base_names_list->to_array;
      for my $base_name (@$base_names) {
        if (Re->m($base_name, $self->{skip_pattern})) {
          next;
        }
        
        my $info_name = $dir_with_slash . $base_name;
        
        my $lstat = (Sys::IO::Stat)undef;
        eval { $lstat = Sys->lstat($info_name); }
        if ($@) {
          if ($warn) {
            warn "Can't lstat($info_name): $@";
          }
          next;
        }
        
        if ($lstat->d) {
          $dirs_stack->push([(object)$dir, $base_name]);
        }
        else {
          $info->{name} = $info_name;
          $cb->($info);
        }
      }
    }
  }
  
  method _find_dir_symlnk : void ($cb : File::Find::Callback, $top_dir : string) {
    
    my $follow_or_follow_fast = $self->follow_or_follow_fast;
    my $follow = $self->{follow};
    
    unless ($top_dir) {
      die "invalid top directory" ;
    }
    
    # canonicalize directory separators
    if (Sys::OS->is_windows) {
      Re->s(my $_ = [$top_dir], ["[/\\\\]", "g"], "/");
      $top_dir = $_->[0];
    }
    
    # no trailing / unless path is root
    unless (&_is_root($top_dir)) {
      Re->s(my $_ = [$top_dir], "/\z", "");
      $top_dir = $_->[0];
    }
    
    my $warn = $self->{warn};
    
    my $topstat = (Sys::IO::Stat)undef;
    if ($follow_or_follow_fast) {
      eval { $topstat = Sys->stat($top_dir); }
      if ($@) {
        if ($warn) {
          warn "Can't stat $top_dir: $@";
        }
        return;
      }
    }
    else {
      eval { $topstat = Sys->lstat($top_dir); }
      if ($@) {
        if ($warn) {
          warn "Can't lstat $top_dir: $@";
        }
        return;
      }
    }
    
    my $is_dir = 0;
    my $abs_dir = (string)undef;
    if ($follow_or_follow_fast) {
      if ($topstat->d) {
        $is_dir= 1;
      }
    }
    else { # no follow
      if ($topstat->d) {
        $is_dir = 1;
      }
    }
    
    unless ($is_dir) {
      die "The top directory \$top_dir must be a directory.";
    }
    
    my $parent_dir = $top_dir;
    
    my $cwd = Cwd->getcwd();
    my $fullname = (string)undef;
    if (&_is_absolute($top_dir)) {
      $fullname = $top_dir;
    }
    elsif ($top_dir eq $self->{current_dir}) {
      $fullname = $cwd;
    }
    else {  # care about any  ../
      $fullname = $self->_contract_name("$cwd/", $top_dir);
    }
    $fullname = $self->Follow_SymLink($fullname);
    
    my $dirs_stack = List->new;
    my $new_fullname = (string)undef;
    my $SE = (object[])undef;
    my $dir = $parent_dir;
    my $dir_rel = $self->{current_dir};
    
    my $dir_with_slash = &_is_root($parent_dir) ? $parent_dir : "$parent_dir/";
    my $fullname_with_slash = &_is_root($fullname) ? $fullname : "$fullname/";
    
    my $info = File::Find::Info->new;
    
    my $lstat = (Sys::IO::Stat)undef;
    
    my $loop_started = 0;
    while (1) {
      
      if ($loop_started) {
        while (1) {
          
          unless ($dirs_stack->length > 0) {
            $SE = undef;
            last;
          }
          
          $SE = (object[])$dirs_stack->pop;
          
          $parent_dir = $SE->[1]->(string);
          $fullname = $SE->[0]->(string);
          
          $dir = &_is_root($parent_dir) ? "$parent_dir$dir_rel" : "$parent_dir/$dir_rel";
          $dir_with_slash = "$dir/";
          $fullname_with_slash = "$fullname/";
          last;
        }
        
        unless ($SE) {
          last;
        }
        $SE = undef;
      }
      else {
        $loop_started++;
      }
      
      {
        $info->{dir} = $parent_dir;
        $info->{name} = $dir;
        $info->{fullname} = $fullname;
        # prune may happen here
        $info->{prune} = 0;
        $cb->($info);
        if ($info->prune) {
          next;
        }
      }
      
      $info->{dir} = $dir;
      
      # Get the list of files in the current directory.
      my $dh = (IO::Dir)undef;
      eval { $dh = IO::Dir->new($fullname); }
      
      if ($@) {
        if ($warn) {
          warn "Can't opendir($fullname): $@";
        }
        next;
      }
      my $base_names_list = StringList->new;
      while (my $dirent = $dh->read) {
        $base_names_list->push($dirent->d_name);
      }
      $dh->close;
      my $base_names = $base_names_list->to_array;
      
      for my $base_name (@$base_names) {
        if (Re->m($base_name, $self->{skip_pattern})) {
          next;
        }
        
        # follow symbolic links / do an lstat
        $new_fullname = $self->Follow_SymLink($fullname_with_slash . $base_name);

        # ignore if invalid symlink
        unless ($new_fullname) {
          $info->{fullname} = $fullname_with_slash . $base_name;
          $info->{name} = $dir_with_slash . $base_name;
          $cb->($info);
          next;
        }
        
        if ($lstat->d) {
          $dirs_stack->push([(object)$new_fullname, $dir, $base_name, 1]);
        }
        else {
          $info->{fullname} = $new_fullname;
          $info->{name} = $dir_with_slash . $base_name;
          $cb->($info);
        }
      }
    }
  }
  
  private method _contract_name : string ($cdir : string, $fn : string) {
    
    if ($fn eq $self->{current_dir}) {
      return Fn->substr($cdir, 0, Fn->rindex($cdir, "/"));
    }
    
    $cdir = Fn->substr($cdir, 0, Fn->rindex($cdir, "/") + 1);
    
    Re->s(my $_ = [$fn], "^\./", "");
    $fn = $_->[0];
    
    my $abs_name = $cdir . $fn;
    
    if (Fn->substr($fn, 0, 3) eq "../") {
      while (1) {
        my $rep = Re->s(my $_ = [$abs_name], "/[^/]*/\.\./+", "/");
        $abs_name = $_->[0];
        unless ($rep) {
          last;
        }
      }
    }
    
    return $abs_name;
  }

  private static method _is_absolute : int ($path : string) {
    if (Sys::OS->is_windows) {
      return !!Re->m($path, "^(?:[A-Za-z]:)?/");
    }
    return length $path && $path->[0] == '/';
  }
  
  private static method _is_root : int ($path : string) {
    if (Sys::OS->is_windows) {
      return !!Re->m($path, "^(?:[A-Za-z]:)?/\z");
    }
    return $path eq "/";
  }
  
  private method PathCombine : string ($Base : string, $Name : string) {
    my $AbsName : string;
    
    if (&_is_absolute($Name)) {
      $AbsName= $Name;
    }
    else {
      $AbsName= $self->_contract_name($Base, $Name);
    }
    
    # (simple) check for recursion
    my $newlen= length($AbsName);
    if ($newlen <= length($Base)) {
      if (($newlen == length($Base) || Fn->substr($Base, $newlen, 1) eq "/")
          && $AbsName eq Fn->substr($Base, 0, $newlen))
      {
        return undef;
      }
    }
    return $AbsName;
  }
  
  private method follow_or_follow_fast : int () {
    return $self->{follow} || $self->{follow_fast};
  }
  
  private method Follow_SymLink : string ($AbsName : string) {
    
    my $NewName = (string)undef;
    
    my $lstat = Sys->lstat($AbsName);
    my $DEV = $lstat->st_dev;
    my $INO = $lstat->st_ino;
    
    my $SLnkSeen = $self->{SLnkSeen};
    
    my $follow_skip = $self->{follow_skip};
    
    my $dangling_symbolic_link = 0;
    while ($lstat->l) {
      
      my $dev_ino_count = $SLnkSeen->get_int("$DEV\034$INO");
      
      if ($dev_ino_count) {
        if ($follow_skip < 2) {
          die "$AbsName is encountered a second time";
        }
        else {
          return undef;
        }
      }
      $dev_ino_count++;
      $SLnkSeen->set("$DEV\034$INO", $dev_ino_count);
      
      my $Link = Sys->readlink($AbsName);
      # canonicalize directory separators
      if (Sys::OS->is_windows) {
        Re->s(my $_ = [$Link], ["\\", "g"], "/");
        $Link = $_->[0];
      }
      $NewName= $self->PathCombine($AbsName, $Link);
      unless ($NewName) {
        if ($follow_skip < 2) {
          die "$AbsName is a recursive symbolic link";
        }
        else {
          return undef;
        }
      }
      else {
        $AbsName= $NewName;
      }
      
      $lstat = Sys->lstat($AbsName);
      $DEV = $lstat->st_dev;
      $INO = $lstat->st_ino;
      
      #  dangling symbolic link
      eval { Sys->stat($AbsName); }
      if ($@) {
        $dangling_symbolic_link = 1;
        return undef;
      }
    }
    
    my $follow = $self->{follow};
    if ($follow && !$dangling_symbolic_link && (my $_ = $SLnkSeen->get_int("$DEV\034$INO"), $SLnkSeen->set("$DEV\034$INO", $_ + 1), $_)) {
      if ( ($follow_skip < 1) || (($lstat->d) && ($follow_skip < 2)) ) {
        die "$AbsName encountered a second time";
      }
      else {
        return undef;
      }
    }
    
    return $AbsName;
  }
  
}
